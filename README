NAME
    ZMQ - A ZMQ2 wrapper for Perl

SYNOPSIS ( HIGH-LEVEL API )
        # echo server
        use ZMQ qw/:all/;

        my $cxt = ZMQ::Context->new;
        my $sock = $cxt->socket(ZMQ_REP);
        $sock->bind($addr);
  
        my $msg;
        foreach (1..$roundtrip_count) {
            $msg = $sock->recvmsg();
            $sock->sendmsg($msg);
        }

        # json (if ZMQ::Serializer::JSON is available)
        use ZMQ::Serializer::JSON;
        $sock->sendmsg_as( json => { foo => "bar" } );
        my $thing = $sock->recvmsg_as( "json" );

        # custom serialization
        ZMQ::register_read_type(myformat => sub { ... });
        ZMQ::register_write_type(myformat => sub { .. });

        $sock->sendmsg_as( myformat => $data ); # serialize using above callback
        my $thing = $sock->recvmsg_as( "myformat" );

SYNOPSIS ( LOW-LEVEL API )
        use ZMQ::Raw;

        my $ctxt = zmq_init($threads);
        my $rv   = zmq_term($ctxt);

        my $msg  = zmq_msg_init();
        my $msg  = zmq_msg_init_size( $size );
        my $msg  = zmq_msg_init_data( $data );
        my $rv   = zmq_msg_close( $msg );
        my $rv   = zmq_msg_move( $dest, $src );
        my $rv   = zmq_msg_copy( $dest, $src );
        my $data = zmq_msg_data( $msg );
        my $size = zmq_msg_size( $msg);

        my $sock = zmq_socket( $ctxt, $type );
        my $rv   = zmq_close( $sock );
        my $rv   = zmq_setsockopt( $socket, $option, $value );
        my $val  = zmq_getsockopt( $socket, $option );
        my $rv   = zmq_bind( $sock, $addr );
        my $rv   = zmq_sendmsg( $sock, $msg, $flags );
        my $msg  = zmq_recvmsg( $sock, $flags );

INSTALLATION
    If you have libzmq registered with pkg-config:

        perl Makefile.PL
        make 
        make test
        make install

    If you don't have pkg-config, and libzmq is installed under
    /usr/local/libzmq:

        ZMQ_HOME=/usr/local/libzmq \
            perl Makefile.PL
        make
        make test
        make install

    If you want to customize include directories and such:

        ZMQ_INCLUDES=/path/to/libzmq/include \
        ZMQ_LIBS=/path/to/libzmq/lib \
        ZMQ_H=/path/to/libzmq/include/zmq.h \
            perl Makefile.PL
        make
        make test
        make install

    If you want to compile with debugging on:

        perl Makefile.PL -g

DESCRIPTION
    The "ZMQ" module is a wrapper of the 0MQ message passing library for
    Perl. It's a thin wrapper around the C API. Please read
    <http://zeromq.org> for more details on ZMQ.

CLASS WALKTHROUGH
    ZMQ::Raw
        Use ZMQ::Raw to get access to the C API such as "zmq_init",
        "zmq_socket", et al. Functions provided in this low level API should
        follow the C API exactly.

    ZMQ::Constants
        ZMQ::Constants contains all of the constants that are known to be
        extractable from zmq.h. Do note that sometimes the list changes due
        to additions/deprecations in the underlying zeromq2 library. We try
        to do our best to make things available (at least to warn you that
        some symbols are deprecated), but it may not always be possible.

    ZMQ::Context
    ZMQ::Socket
    ZMQ::Message
        ZMQ::Context, ZMQ::Socket, ZMQ::Message contain the high-level, more
        perl-ish interface to the zeromq functionalities.

    ZMQ Loading "ZMQ" will make the ZMQ::Context, ZMQ::Socket, and
        ZMQ::Message classes available as well.

BASIC USAGE
    To start using ZMQ, you need to create a context object, then as many
    ZMQ::Socket as you need:

        my $ctxt = ZMQ::Context->new;
        my $socket = $ctxt->socket( ... options );

    You need to call "bind()" or "connect()" on the socket, depending on
    your usage. For example on a typical server-client model you would write
    on the server side:

        $socket->bind( "tcp://127.0.0.1:9999" );

    and on the client side:

        $socket->connect( "tcp://127.0.0.1:9999" );

    The underlying zeromq library offers TCP, multicast, in-process, and ipc
    connection patterns. Read the zeromq manual for more details on other
    ways to setup the socket.

    When sendmsging data, you can either pass a ZMQ::Message object or a
    Perl string.

        # the following two sendmsg() calls are equivalent
        my $msg = ZMQ::Message->new( "a simple message" );
        $socket->sendmsg( $msg );
        $socket->sendmsg( "a simple message" );

    In most cases using ZMQ::Message is redundunt, so you will most likely
    use the string version.

    To receive, simply call "recvmsg()" on the socket

        my $msg = $socket->recvmsg;

    The received message is an instance of ZMQ::Message object, and you can
    access the content held in the message via the "data()" method:

        my $data = $msg->data;

SERIALIZATION
    ZMQ.pm comes with a simple serialization/deserialization mechanism.

    To serialize, use "register_write_type()" to register a name and an
    associated callback to serialize the data. For example, for JSON we do
    the following (this is already done for you in ZMQ.pm if you have
    JSON.pm installed):

        use JSON ();
        ZMQ::register_write_type('json' => \&JSON::encode_json);
        ZMQ::register_read_type('json' => \&JSON::decode_json);

    Then you can use "sendmsg_as()" and "recvmsg_as()" to specify the
    serialization type as the first argument:

        my $ctxt = ZMQ::Context->new();
        my $sock = $ctxt->socket( ZMQ_REQ );

        $sock->sendmsg_as( json => $complex_perl_data_structure );

    The otherside will receive a JSON encoded data. The receivind side can
    be written as:

        my $ctxt = ZMQ::Context->new();
        my $sock = $ctxt->socket( ZMQ_REP );

        my $complex_perl_data_structure = $sock->recvmsg_as( 'json' );

    No serializers are loaded by default. Look for ZMQ::Serializer::*
    namespace in CPAN.

ASYNCHRONOUS I/O WITH ZEROMQ
    By default ZMQ comes with its own zmq_poll() mechanism that can handle
    non-blocking sockets. You can use this by calling zmq_poll with a list
    of hashrefs:

        zmq_poll([
            {
                fd => fileno(STDOUT),
                events => ZMQ_POLLOUT,
                callback => \&callback,
            },
            {
                socket => $zmq_socket,
                events => ZMQ_POLLIN,
                callback => \&callback
            },
        ], $timeout );

    Unfortunately this custom polling scheme doesn't play too well with
    AnyEvent.

    As of zeromq2-2.1.0, you can use getsockopt to retrieve the underlying
    file descriptor, so use that to integrate ZMQ and AnyEvent:

        my $socket = zmq_socket( $ctxt, ZMQ_REP );
        my $fh = zmq_getsockopt( $socket, ZMQ_FD );
        my $w; $w = AE::io $fh, 0, sub {
            while ( my $msg = zmq_recvmsg( $socket, ZMQ_RCVMORE ) ) {
                # do something with $msg;
            }
            undef $w;
        };

NOTES ON MULTI-PROCESS and MULTI-THREADED USAGE
    ZMQ works on both multi-process and multi-threaded use cases, but you
    need to be careful bout sharing ZMQ objects.

    For multi-process environments, you should not be sharing the context
    object. Create separate contexts for each process, and therefore you
    shouldn't be sharing the socket objects either.

    For multi-thread environemnts, you can share the same context object.
    However you cannot share sockets.

FUNCTIONS
  version()
    Returns the version of the underlying zeromq library that is being
    linked. In scalar context, returns a dotted version string. In list
    context, returns a 3-element list of the version numbers:

        my $version_string = ZMQ::version();
        my ($major, $minor, $patch) = ZMQ::version();

  register_read_type($name, \&callback)
    Register a read callback for a given $name. This is used in
    "recvmsg_as()". The callback receives the data received from the socket.

  register_write_type($name, \&callback)
    Register a write callback for a given $name. This is used in
    "sendmsg_as()" The callback receives the Perl structure given to
    "sendmsg_as()"

CAVEATS
    This is an early release. Proceed with caution, please report (or better
    yet: fix) bugs you encounter.

    This module has been tested againt zeromq 2.1.4. Semantics of this
    module rely heavily on the underlying zeromq version. Make sure you know
    which version of zeromq you're working with.

SEE ALSO
    ZMQ::Raw, ZMQ::Context, ZMQ::Socket, ZMQ::Message

    <http://zeromq.org>

    <http://github.com/lestrrat/ZMQ-Perl>

AUTHOR
    Daisuke Maki "<daisuke@endeworks.jp>"

    Steffen Mueller, "<smueller@cpan.org>"

COPYRIGHT AND LICENSE
    The ZMQ module is

    Copyright (C) 2010 by Daisuke Maki

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself, either Perl version 5.8.0 or, at
    your option, any later version of Perl 5 you may have available.

